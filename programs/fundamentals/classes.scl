//Library functions which add classes to scarpet
//
//This implementation makes maps as classes, and each map has to have a __init__ function.
//All functions must take at least one parameter (like in Python 'self'), and then any additional parameters.
//If the function should return nothing, then return just the object itself (with any modifications that the function adds)
//If the function should return something, return a list with the object as the first element, and return value as the second
//For fields, just access and set them like you would access and set values in a normal map
//
//When declaring methods in the class, you can optionally add a _ infront of them to make them private.
//This means that they cannot be called using call_function(), telling the programmer that they're potentially dangerous.
//When calling functions within the class methods, just use call(self:function_name, self, args).
//This allows you to access private functions within the object.
//
//When calling a function, use call_function(), with the object as the first parameter, function name as the second
//and then any arguments at the end. If the function has a return value, then call_function() will return it, otherwise
//it will return null.
//
//
//For an example of all this, see max_heap.scl
//By: Ghoulboy

//Initializes a class with its parent classes, which are passed in as their classes, not their names
//We need the classes to complete the declaration of the class by essentially filling in all the missing methods
new_class(name, declarer, ...parents)->(
    declarer:'__name__' = name;
    declarer:'__parents__' = {}; //Set to avoid duplicate parentage
    for(parents,
        class=_;
        declarer:'__parents__'+=class:'__name__';
        for(class,
            member = _;
            if(member=='__parents__',//Pushing parent' parents into child's parents
                declarer:'__parents__' = declarer:'__parents__' + class:member,
                !has(declarer, member), //stuff which the declarer doesn't override
                declarer:member = class:member
            );
        )
    );
    //Checking for initializer here cos it could have been stolen from a parent class
    if(!has(declarer, '__init__') || type(declarer:'__init__')!='function', throw('missing_constructor', 'value_exception', declarer));
    declarer
);


//Checks that a given input is a class.
//NB: this only checks that it has a valid constructor and has a __name__ property
is_class(class)->
    has(class, '__init__') && type(class:'__init__')=='function' && has(class, '__name__');

//This throws an exception if a given input is not a valid class
check_class(class)->
    if(!is_class(class), throw('invalid_class', 'value_exception', class));

//the object is literally the same as class, except we have called initializer
new_object(class, ...args)->(
    check_class(class);
    object = copy(class); //this is to avoid modifying the original map
    call(object:'__init__', object, ...args);
);

//Basically java instanceof operator
instance_of(object, class_name)->object:'__name__'==class_name || has(object:'__parents__', class_name);

//This is for calling public functions (which don't begin with _)
//You can use call() directly, but this gives return value of functions neatly and blocks you from using private methods
call_function(object, function, ...args)->(
    check_class(object);
    if(!has(object, function), throw('unknown_method', 'value_exception', function));
    if(split(function):0 == '_', throw('hidden_method', 'value_exception', function));
    cb = call(object:function, object, ...args);
    if(type(cb)=='map',
        object = cb; null,
        type(cb)=='list',
        object=cb:0; cb:1,
        // must either return modified object, or a list pair of the object and the return value of the functoion
        throw('invalid_function_return', 'value_exception', cb)
    )
);
