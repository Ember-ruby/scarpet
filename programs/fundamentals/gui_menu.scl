
//Config

global_inventory_sizes={
    'anvil'->3,
    'beacon'->1,
    'blast_furnace'->3,
    'brewing_stand'->5,
    'cartography_table'->3,
    'crafting'->10,
    'enchantment'->2,
    'furnace'->3,
    'generic_3x3'->9,
    'generic_9x1'->9,
    'generic_9x2'->18,
    'generic_9x3'->27,
    'generic_9x4'->36,
    'generic_9x5'->45,
    'generic_9x6'->54,
    'grindstone'->3,
    'hopper'->5,
    'lectern'->1,
    'loom'->4,
    'merchant'->3,
    'shulker_box'->27,
    'smithing'->4,
    'smoker'->3,
    'stonecutter'->2,
};

//Certain names are subject to change, so instead I'll store them in global variables while I'm still fiddling with exact nomenclature
global_static_buttons='static_buttons';
global_dynamic_buttons='dynamic_buttons';
global_storage_slots='storage_slots';
global_dynamic_slots='dynamic_slots';
global_pages='pages';
global_main_page='main_page_title';
global_current_page='current_page';
global_page_switcher='navigation_buttons';
global_anvil_rename_item='on_anvil_modify_item';
global_crafting_recipe_select='on_select_crafting_recipe';

new_gui_menu(gui_screen)->( //Stores GUI data in intermediary map form, so the programmer can call them at any time with call_gui_menu() function
    if(type(gui_screen)!='map',
        throw('Invalid gui creation: '+gui_screen)
    );

    if(has(gui_screen, global_pages) && !has(gui_screen:global_pages, gui_screen:global_main_page),
        throw('Tried to create a GUI Menu with page functionality, but did not find a main page with the name '+gui_screen:global_main_page)
    );

    gui_screen:global_current_page = gui_screen:global_main_page;

    {
        'inventory_shape'->_(outer(gui_screen))->__get_screen_shape(gui_screen), //shape of the inventory, copied from above
        'title'->__get_screen_title(gui_screen), //Fancy GUI title
        'on_created'->_(screen, outer(gui_screen))->__create_gui_screen(screen, gui_screen),
        'callback'->_(screen, player, action, data, outer(gui_screen))->(
            __screen_callback(screen, player, action, data, gui_screen, global_inventory_sizes:__get_screen_shape(gui_screen))
        ),
    }
);

call_gui_menu(gui_menu, player)->( //Opens the screen to the player, returns screen for further manipulation
    screen = create_screen(player, call(gui_menu:'inventory_shape'), gui_menu:'title', gui_menu:'callback');
    call(gui_menu:'on_created', screen);
    screen
);

__create_gui_screen(screen, gui_screen)->(// Fiddling with the screen right after it's made to add fancy visual bits
    gui_page=__get_gui_page(gui_screen);
    for(gui_page:global_static_buttons,
        [item, count, nbt] = __parse_icon(gui_page:global_static_buttons:_:0);
        inventory_set(screen, _, count, item, nbt)
    );
    for(gui_page:global_dynamic_buttons,
        [item, count, nbt] = __parse_icon(gui_page:global_dynamic_buttons:_:0);
        inventory_set(screen, _, count, item, nbt)
    );
    for(gui_page:global_storage_slots,
        [item, count, nbt] = gui_page:global_storage_slots:_ || ['air', 0, null];
        inventory_set(screen, _, count, item, nbt)
    );
    for(gui_page:global_page_switcher,
        [item, count, nbt] = __parse_icon(gui_page:global_page_switcher:_:0);
        inventory_set(screen, _, count, item, nbt)
    );
);

__screen_callback(screen, player, action, data, gui_screen, inventory_size)->(
    gui_page=__get_gui_page(gui_screen);

    slot = data:'slot'; //Grabbing slot, this is the focus of the action

    if(action=='pickup', //This is equivalent of clicking (button action)
        if(has(gui_page:global_static_buttons, slot), //Plain, vanilla button
            call(gui_page:global_static_buttons:slot:1, player, data:'button'),
            has(gui_page:global_dynamic_buttons, slot), //A more exciting button
            call(gui_page:global_dynamic_buttons:slot:1, screen, player, data:'button'),
            has(gui_page:global_page_switcher, slot), //Switching screens
            gui_screen:global_current_page = gui_page:global_page_switcher:slot:1;
            for(gui_page:global_storage_slots, //Saving storage slots when switching screens
                gui_page:global_storage_slots:_ = inventory_get(screen, _);
            );
            loop(inventory_size, //Clearing inventory before switching
                inventory_set(screen, _, 0)
            );
            close_screen(screen);
            new_screen = create_screen(player, __get_screen_shape(gui_screen), __get_screen_title(gui_screen), _(screen, player, action, data, outer(gui_screen))->(
                __screen_callback(screen, player, action, data, gui_screen, global_inventory_sizes:__get_screen_shape(gui_screen))
            ));
            __create_gui_screen(new_screen, gui_screen)
        );
    );

    //Special effects for special GUI types
    inventory_shape = __get_screen_shape(gui_screen);
    if(inventory_shape == 'anvil',
        if(has(gui_page, global_anvil_rename_item) && action=='slot_update' && slot==2 && has(data, 'stack') && data:'stack',
            call(gui_page:global_anvil_rename_item, player, screen, item_display_name(data:'stack'), screen_property(screen, 'level_cost'))
        ),
        has({'crafting_table', 'furnace', 'blast_furnace', 'smoker'}, inventory_shape), //If it is an inventory with green crafting book item in GUI
        if(has(gui_page, global_crafting_recipe_select) && action=='select_recipe',
            call(gui_page:global_crafting_recipe_select, player, screen, data:'recipe', data:'craft_all')
        ),
    );


    //Saving items in storage slots when closing
    if(action=='close',
        for(gui_page:global_storage_slots,
            gui_page:global_storage_slots:_ = inventory_get(screen, _);
        );
    );

    if(action=='slot_update' && has(gui_page:global_dynamic_slots,slot), //Updating dynamic slots
        call(gui_page:global_dynamic_slots:slot:1, player, screen, slot, data:'stack')
    );

    //Disabling quick move cos it messes up the GUI, and there's no reason to allow it
    //Also preventing the player from tampering with button slots
    //Unless the slot is marked as a storage slot, in which case we allow it
    if((action=='quick_move'||slot<inventory_size)&&!has(gui_page:global_storage_slots,slot)&&!has(gui_page:global_dynamic_slots,slot),
        'cancel'
    );
);


//If gui supports page functionality, returns current page, else returns the gui screen
__get_gui_page(gui_screen)->if(has(gui_screen, global_pages),
    gui_screen:global_pages:(gui_screen:global_current_page),
    gui_screen
);


//Gets the title for the current page of the screen.
//A title within the page gets first priority, if not, then use the title defined in the outermost map,
//And if that is not there, then the same title as the main page.
//And failing that, throw an error
__get_screen_title(gui_screen)->(
    gui_page=__get_gui_page(gui_screen);

    if(!has(gui_screen, global_pages),
        gui_screen:'title',
        has(gui_page, 'title'),
        gui_page:'title',
        has(gui_screen, 'title'),
        gui_screen:'title',
        has(gui_screen:global_pages:(gui_screen:global_main_page), 'title'),
        gui_screen:global_pages:(gui_screen:global_main_page):'title',
        throw('No title defined!')
    )
);

//Same as above, but for inventory shapes
__get_screen_shape(gui_screen)->(
    gui_page=__get_gui_page(gui_screen);

    inventory_shape = if(!has(gui_screen, global_pages),
        gui_screen:'inventory_shape',
        has(gui_page, 'inventory_shape'),
        gui_page:'inventory_shape',
        has(gui_screen, 'inventory_shape'),
        gui_screen:'inventory_shape',
        has(gui_screen:global_pages:(gui_screen:global_main_page), 'inventory_shape'),
        gui_screen:global_pages:(gui_screen:global_main_page):'inventory_shape',
        throw('No GUI shape defined!')
    );

    if(!has(global_inventory_sizes, inventory_shape),
        throw('Invalid gui creation: Must be one of '+keys(global_inventory_sizes)+', not '+inventory_shape)
    );
    inventory_shape
);

//Parses the item used as slot icon
//If it's a string, returns [item_name, 1, null],
//If it's a list of length 2, second item is the name of the item
//If it's a triplet, then return that (making the assumption that it's a triplet of [item, count, nbt])
//IF it's a list of length 4, first three arguments are [item, count, nbt], fourth is item name.
__parse_icon(icon)->if(type(icon)=='string',
    [icon, 1, null],
    type(icon)=='list',
    if(length(icon)==2,
        [icon:0, 1, str('{display:{Name:\'{"text":"%s"}\'}}', icon:1)],
        length(icon)==3,
        icon,
        length(icon)==4,
        icon:2 = icon:2 || nbt({}); //JIC input nbt was null
        put(icon:2, 'display', nbt(str('{display:{Name:\'{"text":"%s"}\'}}', icon:1)));
        icon
    )
);
