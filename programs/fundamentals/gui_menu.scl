
//Config

global_inventory_sizes={ //cos inventory_size() function doesn't work properly with sone of these
    'anvil'->3,
    'beacon'->1,
    'blast_furnace'->3,
    'brewing_stand'->5,
    'cartography_table'->3,
    'crafting'->10,
    'enchantment'->2,
    'furnace'->3,
    'generic_3x3'->9,
    'generic_9x1'->9,
    'generic_9x2'->18,
    'generic_9x3'->27,
    'generic_9x4'->36,
    'generic_9x5'->45,
    'generic_9x6'->54,
    'grindstone'->3,
    'hopper'->5,
    'lectern'->1,
    'loom'->4,
    'merchant'->3,
    'shulker_box'->27,
    'smithing'->4,
    'smoker'->3,
    'stonecutter'->2,
};

new_gui_menu(gui_screen)->( //Stores GUI data in intermediary map form, so the programmer can call them at any time with call_gui_menu() function
    if(type(gui_screen)!='map',
        throw('Invalid gui creation: '+gui_screen)
    );

    if(has(gui_screen, 'pages') && !has(gui_screen:'pages', gui_screen:'main_page_title'),
        throw('Tried to create a GUI Menu with page functionality, but did not find a main page with the name '+gui_screen:'main_page_title')
    );

    gui_screen:'current_page' = gui_screen:'main_page_title';

    {
        'inventory_shape'->_(outer(gui_screen))->__get_screen_shape(gui_screen), //shape of the inventory, copied from above
        'title'->__get_screen_title(gui_screen), //Fancy GUI title
        'on_created'->_(screen, outer(gui_screen))->__create_gui_screen(screen, gui_screen),
        'callback'->_(screen, player, action, data, outer(gui_screen))->(
            __screen_callback(screen, player, action, data, gui_screen, global_inventory_sizes:__get_screen_shape(gui_screen))
        ),
    }
);

call_gui_menu(gui_menu, player)->( //Opens the screen to the player, returns screen for further manipulation
    screen = create_screen(player, call(gui_menu:'inventory_shape'), gui_menu:'title', gui_menu:'callback');
    call(gui_menu:'on_created', screen);
    screen
);

__create_gui_screen(screen, gui_screen)->(// Fiddling with the screen right after it's made to add fancy visual bits
    gui_page=_get_gui_page(gui_screen);
    for(gui_page:'static_buttons',
        [item, count, nbt] = __parse_icon(gui_page:'static_buttons':_:0);
        inventory_set(screen, _, count, item, nbt)
    );
    for(gui_page:'dynamic_buttons',
        [item, count, nbt] = __parse_icon(gui_page:'dynamic_buttons':_:0);
        inventory_set(screen, _, count, item, nbt)
    );
    for(gui_page:'storage_slots',
        [item, count, nbt] = gui_page:'storage_slots':_ || ['air', 0, null];
        inventory_set(screen, _, count, item, nbt)
    );
    for(gui_page:'dynamic_storage_slots',
        [item, count, nbt] = gui_page:'dynamic_storage_slots':_:0 || ['air', 0, null];
        inventory_set(screen, _, count, item, nbt)
    );
    for(gui_page:'navigation_buttons',
        [item, count, nbt] = __parse_icon(gui_page:'navigation_buttons':_:0);
        inventory_set(screen, _, count, item, nbt)
    );
);

__screen_callback(screen, player, action, data, gui_screen, inventory_size)->(
    gui_page=_get_gui_page(gui_screen);

    slot = data:'slot'; //Grabbing slot, this is the focus of the action

    if(action=='pickup', //This is equivalent of clicking (button action)
        if(has(gui_page:'static_buttons', slot), //Plain, vanilla button
            call(gui_page:'static_buttons':slot:1, player, data:'button'),
            has(gui_page:'dynamic_buttons', slot), //A more exciting button
            call(gui_page:'dynamic_buttons':slot:1, screen, player, data:'button'),
            has(gui_page:'navigation_buttons', slot), //Switching screens
            _switch_page(gui_screen, gui_page, gui_page:'navigation_buttons':slot:1, screen, player)
        );
    );

    if(action=='slot_update' && has(gui_page:'dynamic_storage_slots',slot), //Updating dynamic slots
        call(gui_page:'dynamic_storage_slots':slot:1, player, screen, slot, data:'stack')
    );

    //Special effects for special GUI types
    //Could have used handle_event() and custom events API, but these events are tied into gui_menu.scl script
    //Risk of usin events API is that programmer might try to use the events in an incorrect manner, causing problems
    //And it's not like it simplifies the code much on either end tbh.
    inventory_shape = __get_screen_shape(gui_screen);
    if(inventory_shape == 'anvil',
        if(has(gui_page, 'on_anvil_modify_item') && action=='slot_update' && slot==2 && has(data, 'stack') && data:'stack',
            call(gui_page:'on_anvil_modify_item', player, screen, item_display_name(data:'stack'), screen_property(screen, 'level_cost'))
        ),
        has({'crafting_table', 'furnace', 'blast_furnace', 'smoker'}, inventory_shape), //If it is an inventory with green crafting book item in GUI
        if(has(gui_page, 'on_select_crafting_recipe') && action=='select_recipe',
            call(gui_page:'on_select_crafting_recipe', player, screen, data:'recipe', data:'craft_all')
        ),
        inventory_shape=='lectern',
        if(action=='button',
            button = data:'button';
            if(has(gui_page, 'on_take_book') && button==3,
                call(gui_page:'on_take_book', player, screen)
            );
            if(has(gui_page, 'on_flip_page') && button < 3,
                page = screen_property(screen, 'page');
                call(gui_page:'on_flip_page', player, screen, button, 2*button-3+page) //This looks silly, but the page number is not immediately updated, so I modify it instead
            )
        ),
        inventory_shape=='loom',
        if(has(gui_page, 'on_select_banner_pattern'),
            if(action=='button',
                global_action_cache={
                    'data'->data,
                    'active'->true
                },
                global_action_cache:'active' && action=='slot_update',
                call(gui_page:'on_select_banner_pattern', player, screen, global_action_cache:'data':'button', parse_nbt(data:'stack':2):'BlockEntityTag':'Patterns':(-1):'Pattern');
                global_action_cache:'active'=false
            )
        ),
        inventory_shape=='stonecutter',
        if(has(gui_page, 'on_select_stonecutting_pattern'),
            if(action=='button',
                global_action_cache={
                    'data'->data,
                    'active'->true
                },
                global_action_cache:'active' && action=='slot_update',
                call(gui_page:'on_select_stonecutting_pattern', player, screen, global_action_cache:'data':'button', data:'stack');
                global_action_cache:'active'=false
            )
        ),
        inventory_shape=='enchantment',//'on_select_enchantment'
        if(has(gui_page, 'on_select_enchantment'),
            if(action=='button',
                global_action_cache={
                    'data'->data,
                    'active'->true
                },
                global_action_cache:'active' && action=='slot_update',
                button = global_action_cache:'data':'button' + 1;
                call(gui_page:'on_select_enchantment',
                    player, screen,
                    screen_property(screen, 'enchantment_power_'+button),
                    screen_property(screen, 'enchantment_id_'+button),
                    screen_property(screen, 'enchantment_level_'+button),
                );
                global_action_cache:'active'=false
            )
        ),
    );

    //Saving items in storage and dynamic slots when closing
    if(action=='close',
        for(gui_page:'storage_slots',
            gui_page:'storage_slots':_ = inventory_get(screen, _);
        );
        for(gui_page:'dynamic_storage_slots',
            gui_page:'dynamic_storage_slots':_:0 = inventory_get(screen, _);
        );
    );

    acb = ''; //allowing programmer to cancel event in additional screen callback function

    if(has(gui_page, 'additional_screen_callback'),
        acb = call(gui_page:'additional_screen_callback', screen, player, action, data, gui_screen)
    );

    //Disabling quick move cos it messes up the GUI, and there's no reason to allow it
    //Also preventing the player from tampering with button slots
    //Unless the slot is marked as a storage slot, in which case we allow it
    //Also unless the action is clicking a button within the GUI, cos it has useful functionality
    //But if the programmer decided to cancel event using the additional screen callback, it will be cancelled regardless
    if((action=='quick_move'||slot<inventory_size) && !(has(gui_page:'storage_slots',slot)||has(gui_page:'dynamic_storage_slots',slot)) && action!='button' || acb=='cancel',
        'cancel'
    );
);

global_action_cache={ //Sometimes a slot_update with important information comes after the event that triggered it
    'data'->null,
    'active'->false
};

//If gui supports page functionality, returns current page, else returns the gui screen
_get_gui_page(gui_screen)->if(has(gui_screen, 'pages'),
    gui_screen:'pages':(gui_screen:'current_page'),
    gui_screen
);


//Gets the title for the current page of the screen.
//A title within the page gets first priority, if not, then use the title defined in the outermost map,
//And if that is not there, then the same title as the main page.
//And failing that, throw an error
__get_screen_title(gui_screen)->(
    gui_page=_get_gui_page(gui_screen);

    if(!has(gui_screen, 'pages'),
        gui_screen:'title',
        has(gui_page, 'title'),
        gui_page:'title',
        has(gui_screen, 'title'),
        gui_screen:'title',
        has(gui_screen:'pages':(gui_screen:'main_page_title'), 'title'),
        gui_screen:'pages':(gui_screen:'main_page_title'):'title',
        throw('No title defined!')
    )
);

//Same as above, but for inventory shapes
__get_screen_shape(gui_screen)->(
    gui_page=_get_gui_page(gui_screen);

    inventory_shape = if(!has(gui_screen, 'pages'),
        gui_screen:'inventory_shape',
        has(gui_page, 'inventory_shape'),
        gui_page:'inventory_shape',
        has(gui_screen, 'inventory_shape'),
        gui_screen:'inventory_shape',
        has(gui_screen:'pages':(gui_screen:'main_page_title'), 'inventory_shape'),
        gui_screen:'pages':(gui_screen:'main_page_title'):'inventory_shape',
        throw('No GUI shape defined!')
    );

    if(!has(global_inventory_sizes, inventory_shape),
        throw('Invalid gui creation: Must be one of '+keys(global_inventory_sizes)+', not '+inventory_shape)
    );
    inventory_shape
);

//Parses the item used as slot icon
//If it's a string, returns [item_name, 1, null],
//If it's a list of length 2, second item is the name of the item
//If it's a triplet, then return that (making the assumption that it's a triplet of [item, count, nbt])
//IF it's a list of length 4, first three arguments are [item, count, nbt], fourth is item name.
__parse_icon(icon)->if(type(icon)=='string',
    [icon, 1, null],
    type(icon)=='list',
    if(length(icon)==2,
        [icon:0, 1, str('{display:{Name:\'{"text":"%s"}\'}}', icon:1)],
        length(icon)==3,
        icon,
        length(icon)==4,
        icon:2 = icon:2 || nbt({}); //JIC input nbt was null
        put(icon:2, 'display', nbt(str('{display:{Name:\'{"text":"%s"}\'}}', icon:1)));
        icon
    )
);

_switch_page(gui_screen, gui_page, new_page_name, old_screen, player)->(
    gui_screen:'current_page' = new_page_name; //Changing current page
    for(gui_page:'storage_slots', //Saving storage slots when switching screens
        gui_page:'storage_slots':_ = inventory_get(old_screen, _);
    );
    for(gui_page:'dynamic_storage_slots', //Saving dynamic slots when switching screens
        gui_page:'dynamic_storage_slots':_:0 = inventory_get(old_screen, _);
    );
    loop(inventory_size, //Clearing inventory before switching
        inventory_set(old_screen, _, 0)
    );
    close_screen(old_screen);
    new_screen = create_screen(player, __get_screen_shape(gui_screen), __get_screen_title(gui_screen), _(screen, player, action, data, outer(gui_screen))->(
        __screen_callback(screen, player, action, data, gui_screen, global_inventory_sizes:__get_screen_shape(gui_screen))
    ));
    __create_gui_screen(new_screen, gui_screen)
);
