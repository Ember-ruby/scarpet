//A library script which contains the class of max heaps, implemented using classes.scl
//If you want to know how a max heap works, see documentation of min_heaps.sc (which works very differently)
//
//To use this, import it into your script, and then import 'call_function' from classes.scl, so you can use the methods
//At the bottom, commented out, is an example script showing how it works and how to use it.
//
//By: Ghoulboy

import('classes', 'new_class', 'new_object', 'call_function');

max_heap_class = new_class('MaxHeap', {
    '__init__'->_(self, max_size)->(
        self:'max_size' = max_size;
        self:'size' = 0;
        _Heap = [];
        loop(max_size, _Heap+=0);
        self:'_Heap' = _Heap;
        self:'_FRONT' = 0;
        self
    ),
    '_parent'->_(self, pos)->[self, bitwise_shift_right(pos, 1)],
    '_leftChild'->_(self, pos)->[self, bitwise_shift_left(pos, 1)],
    '_rightChild'->_(self, pos)->[self, bitwise_shift_left(pos, 1) + 1],
    '_isLeaf'->_(self, pos)->[self, pos*2 > self:'size'],
    '_swap'->_(self, fpos, spos)->(
        temp = self:'_Heap':fpos;
        self:'_Heap':fpos = self:'_Heap':spos;
        self:'_Heap':spos = temp;
        self
    ),
    '_maxHeapify'->_(self, pos) -> (
        //Getting all this stuff here cos it doesn't change and clutters up the code like crazy
        left = call(self:'_leftChild', self, pos):1;
        right = call(self:'_rightChild', self, pos):1;
        selfpos = self:'_Heap':pos;
        leftchild = self:'_Heap':left;
        rightchild = self:'_Heap':right;
        if(!call(self:'_isLeaf', self, pos):1 && (selfpos < leftchild || selfpos < rightchild),
            heapifypos = if(leftchild>rightchild, left, right);
            call(self:'_swap', self, pos, heapifypos);
            call(self:'_maxHeapify', self, heapifypos)
        );
        self
    ),
    'insert'->_(self, element) -> (
        if(self:'size' < self:'max_size',
            self:'size' += 1;
            self:'_Heap':(self:'size') = element;
            current = self:'size';
            while(self:'_Heap':current > self:'_Heap':(call(self:'_parent', self, current):1), self:'max_size',
                call(self:'_swap', self, current, call(self:'_parent', self, current):1);
                current = call(self:'_parent', self, current):1
            );
        );
        self
    ),
    'remove'->_(self)->(
        popped = self:'_Heap':(self:'_FRONT');
        self:'_Heap':(self:'_FRONT') = self:'_Heap':(self:'size');
        self:'size' += -1;
        call(self:'_maxHeapify', self, self:'_FRONT');
        [self, popped]
    ),
});

max_heap(outer(max_heap_class), maxsize) -> new_object(max_heap_class, maxsize);

//This is an example of using a MaxHeap
//heap = new_object(max_heap, 5);
//print(heap:'_Heap');					=> [0, 0, 0, 0, 0]
//call_function(heap, 'insert', 1);
//print(heap:'_Heap');					=> [1, 0, 0, 0, 0]
//call_function(heap, 'insert', 3);
//print(heap:'_Heap');					=> [3, 1, 0, 0, 0]
//call_function(heap, 'insert', 3);
//print(heap:'_Heap');					=> [3, 3, 0, 1, 0]
//print(call_function(heap, 'remove')); => 3
//print(heap:'_Heap');					=> [3, 1, 0, 1, 0] //The extra 1 here is becase we don't remove it from the list, rather overwrite it later
//call_function(heap, 'insert', 5);
//print(heap:'_Heap');					=> [5, 3, 0, 1, 0] //The first 1 from before has overwritten the trailing 1
//call_function(heap, 'insert', 6);
//print(heap:'_Heap');					=> [6, 5, 3, 1, 0]
//print(call_function(heap, 'remove'));
//print(heap:'_Heap');					=> [5, 3, 0, 1, 0]
//
//print(heap); => {remove: _, __name__: MaxHeap, _Heap: [5, 3, 0, 1, 0], _leftChild: _, _isLeaf: _, _rightChild: _, _maxHeapify: _, __init__: _, _swap: _, insert: _, _parent: _, _FRONT: 0, size: 3, max_size: 5}